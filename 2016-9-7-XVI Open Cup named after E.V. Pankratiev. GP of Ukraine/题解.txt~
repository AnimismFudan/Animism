Problem A－Associated Vertices
负责：郭雨 王鹏
情况：2AC
题意：
	N个点M条边的有向图
	定义(A,B)关联，当且仅当存在点C，点C能到达点A，且点C能到达点B
	问图中关联的（A,B）数量
	N<=10000 M<=10000
	时限3s
思路：
	根据数据范围推测平方级别的算法可以通过
	首先跑一遍tarjan缩点，将图简化为拓扑图，并得到拓扑序
	按拓扑序枚举Ai，Bi，则（Ai，Bi）有关联，当且仅当：
	（1） （Xi，Bi）关联，且存在边（Xi，Ai）
	（2） （Ai，Yi）关联，且存在边（Yi，Bi）
	由于按拓扑序枚举，这些点对都已在之前被枚举过
	需要存下所有点对是否关联
	复杂度O(N*M+N^2)

Problem E－Effective Hiring
负责：All
情况：AC
题意：
	N个人，每个人能担任领导，下属，或者两者都行。每个人有经验值Ci，有工资Si
	现在要选出K对人，要求每对组合为一个领导配一个下属，且要求组内领导的经验值不小于下属
	使得总Si最小
	N*K<=1e5 2*K<=N
思路：
	DP
	将人按Ci排序，Ci相同的按 领导、两者、下属 的顺序排序
	f[i][j][k]表示前i人，选出j个领导，k个下属的最小代价
	只要保证一直有j>=k即可
	由于N*K<=1e5 K<=300（左右）
	因此复杂度为O(N*K^2)，可过

Problem F――First And Last
负责：郭雨
情况：AC
题意：
	找出最小的n，满足2^n的十进制表示的最高位为A，最低位为B
思路：
	最低位仅有2、4、6、8，一共有36+5种组合
	猜测n不会太大
	因此暴力枚举n，模拟2^n的变化。最低位使用mod操作即可，最高位使用double模拟，忽略掉低位对高位的影响

Problem J――Joining Powers
负责：郭雨
题意：
	存在数列S(x):1^x , 2^x , 3^x ……
	现有Q个询问，每个询问给定了M个Ai，要求将M个S(Ai)合并、去重、排序，求出第N小的元素
	保证答案不超过1e17
	Q<=987
	M<=42
思路：
	很显然x<=56（否则2^x就超过了1e17）
	二分答案，转化为check不超过Mid的元素有几个
	可以枚举Ai，并开方计算答案
	（实现上使用了取log，转开方为除法，有精度损失，需要进行O(1)程度的check）
	记S(i)中不超过Mid的元素个数为Num(i)
	很显然会有重复，如(x^3)^2=(x^2)^3
	可以发现，S(Ai)与S(Aj)之间的公共部分，为S(lcm(Ai,Aj))
	三个及以上同理，这里需要容斥
	由于M较大，2^M容斥行不通
	可以看到，lcm也必须满足<=56的条件
	因此采用dp预处理，f[i][j]表示已经容斥了前i个元素，S(j)对答案贡献的倍率是多少（存在负数）
	总数=sigma(f[M][i]*Num(i))
	注意需要事先挖掉数列中的1，最后补上去（1^x的x可以取任意大，不满足前提条件）
	复杂度O(Q*(log(1e17)*M*log(56)+M*56))

Problem M――Merging
负责：郭雨
题意：
	给定K个多项式数列S(X)=sigma(Xi*n^i)  0<=i<=7
	现要求将K个S(X)合并、排序（不去重），求出第N小的元素
	保证答案不超过1e17
	K<=3e4 N<=1e5
题解：
	由于不需要去重，K和N的范围都很小，直接用堆维护最小值即可
	复杂度O(NlogK*8)

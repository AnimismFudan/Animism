Problem B——Vector Field
负责：王鹏
情况：2AC
题意：
	在一个二维平面上有n个弹射器，每个弹射器上各有上下左右中的一种方向。当小球碰到这个弹射器后，会沿着弹射器的方向前进，同时弹射器会消失，问小球最多能经过多少个弹射器。
题解：
	枚举初始位置，链表模拟即可。

Problem E——Enclose Points
负责：郭雨
情况：刚敲完，还没调过……
题意：
	给定一张平面图，给定若干点，查询点是否在平面图内
	保证询问点与线段间至少有1e-4的距离
题解：
	建立平面图，挖出外侧轮廓
	将外侧轮廓的线段取出，扫描线维护平衡树，用射线法查询点是否在平衡树内即可
	复杂度O(NlogN)

Problem F——Marching Course
负责：王鹏
情况：2AC
题意：
	一张无向图，每条边上有两个参数：价值v和长度d.
	现在有个马戏团从点1出发，要在p的时间内回到点1，在这段时间里，他获得的收益是sigma(dt * v / d)，求总收益最大值。
题解：
	令f[u][t]表示在t时刻，马戏团在u点能获得的最大收益，转移：1.f[u][t - 1] -> f[u][t]. 2.f[v][t - d] -> f[u][t].

Problem G——Surface Area of Cubes
负责：郭雨
情况：AC
题意：
	给定A*B*C的正方体，N个位置的方块被挖去
	计算剩余体的表面积（包括外侧看不到的位置的表面积）
	N<=1000
题解：
	模拟即可
	只要某个被挖去的方块的一侧不与另一个被挖去方块相邻，即可贡献1的价值
	再处理侧面的情况，即可得解
	
Problem H——Marching Course
负责：郭雨　罗齐尧　王鹏
情况：2AC
题意：
	在二位平面上给定n条有向线段，保证这些线段联通(具体意思见原题)，现在你有一个电锯，求规划平面上路径使得每条线段都能沿着规定的方向被电锯切开，且能使电锯移动回起点，且使得电锯移动的距离最短。
题解：
	首先每条线段的长度一定会加到答案里，然后就是我们要使额外的路径最短。我们法发现电锯需要移动到起点，想到构造欧拉回路，之后变成了给定A集合n个点，B集合n个点，让A,B集合的点配对且使距离和最短，这个用km算法可以解决。一开始写的费用流不知道为什么t了。

Problem I——Live Programming
负责：郭雨
情况：2AC
题意：
	你要给一个晚会安排节目
	每个节目有三个属性：时间长度Ti，贡献价值Pi，特征值Fi
	你可以选择任意数量（至少一个）的节目进入晚会，并任意排序，但总时长不超过T
	每个被选择的节目会贡献Pi的价值，并且相邻的两个节目会贡献-(Fi-Fj)^2的价值
	最大化价值和
	N，T<=4000
题解：
	由于N与T的范围很小，考虑平方级别的算法
	如果每个节目是否进入晚会已经确定，则节目顺序必然按Fi单调
	（很显然，Pi总和不变，且相邻Fi之差最小）
	将节目按Fi排序后，考虑Dp[t][i]表示耗时t，已经取到第i个节目
	Dp[t+a[i]][i] = Dp[t][j] + P[i] - F[i]^2 - F[j]^2 + 2 * F[i] * F[j]
	将与i有关的属性移动到左侧，右侧可以转化为kx+b的形式
	采用斜率优化，由于x=F[i]单调增，因此可以单调维护凸壳
	复杂度O(N*T)
	第一次挂是由于使用叉乘判断直线交点相对位置时爆long long了……-_-|||
	修改成整数除法估算交点位置后通过
	
Problem J－Black Company
负责：郭雨 王鹏 罗齐尧
情况：2AC
题意：
	给定N个点，M条边的无向图，每个点有权值Ci
	现在要求给每个点部署权值Pi，并满足任意两个距离不超过2的点i、j之间有：
	Ci < Cj 当且仅当 Pi < Pj
	要求sigma Pi 最小
题解：
	我们将每个点按Ci从小到大排序，对于当前点i，查找所有与其距离不超过2的点j，如果点j被更新过，则用Pj + 1 更新Pi
	这样可以保证Cj < Ci 时有Pj < Pi，并且Pi没有必要取更大
	Ci相同时分段处理，保证只用小于Ci的Cj更新即可
	
	但这个算法不能满足当且仅当的条件
	如如下样例：
	N=5
	Ci为1 3 3 3 2
	五个点形成一个环
	最左侧的3的Pi会被取为2，最右侧的3的Pi会被取为3
	没有满足Pi < Pj时，Ci < Cj的条件
	因此需要特殊处理
	（这也是第一次WA的地方）
	
	由于Ci不同时，我们不会出现问题（距离小于2的都更新了）
	Ci相同时，距离小于等于2的点之间构成一个集合
	因此用并查集维护，Pi取该集合内的Pi最大值即可
	这样就解决了充分必要的问题
	
	另一个问题，距离为2的点对可能很多，超出O(N)级别
	因此我们另开一个数组S[x]，记录与x的距离小于1的点的Pi最大值
	更新Pi时查询与i相邻的S[x]即可
	更新S[x]也只需要用相邻的点更新
	复杂度确定在O(N)
	
	总复杂度O(NlogN + N)
	
